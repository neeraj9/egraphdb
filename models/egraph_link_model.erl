%%%-------------------------------------------------------------------
%%% @author neerajsharma
%%% @copyright (C) 2018, Neeraj Sharma
%%% @doc
%%%
%%% @end
%%% %CopyrightBegin%
%%%
%%% Copyright Neeraj Sharma <neeraj.sharma@alumni.iitg.ernet.in> 2017.
%%% All Rights Reserved.
%%%
%%% Licensed under the Apache License, Version 2.0 (the "License");
%%% you may not use this file except in compliance with the License.
%%% You may obtain a copy of the License at
%%%
%%%     http://www.apache.org/licenses/LICENSE-2.0
%%%
%%% Unless required by applicable law or agreed to in writing, software
%%% distributed under the License is distributed on an "AS IS" BASIS,
%%% WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
%%% See the License for the specific language governing permissions and
%%% limitations under the License.
%%%
%%% %CopyrightEnd%
%%%-------------------------------------------------------------------
-module(egraph_link_model).
%% -behaviour(egraph_callback).
-export([init/0, init/2, terminate/1, % CRUD
         validate/2, create/3, read/2, update/3, delete/2]).
-export([create/4, update/4]).
-export([search/2]).
-export([read_all_resource/3]).
-export_type([egraph_k/0]).

-include("egraph_constants.hrl").

-type egraph_k() :: binary().
-type state() :: term().

-define(LAGER_ATTRS, [{type, model}]).

%%%===================================================================
%%% API
%%%===================================================================

%%%===================================================================
%%% Callbacks
%%%===================================================================

%% @doc Initialize the state that the handler will carry for
%% a specific request throughout its progression. The state
%% is then passed on to each subsequent call to this model.
-spec init() -> state().
init() ->
    nostate.

init(_, QsProplist) ->
    [{proplist, QsProplist}].

%% @doc At the end of a request, the state is passed back in
%% to allow for clean up.
-spec terminate(state()) -> term().
terminate(_State) ->
    ok.

%% @doc Return, via a boolean value, whether the user-submitted
%% data structure is considered to be valid by this model's standard.
-spec validate(egraph_k() | term(), state()) -> {boolean(), state()}.
validate(V, State) ->
    {is_map(V) orelse is_list(V) orelse is_boolean(V), State}.

%% @doc Create a new entry. If the id is `undefined', the user
%% has not submitted an id under which to store the resource:
%% the id needs to be generated by the model, and (if successful),
%% returned via `{true, GeneratedId}'.
%% Otherwise, a given id will be passed, and a simple `true' or
%% `false' value may be returned to confirm the results.
%%
%% The created resource is validated before this function is called.
-spec create(egraph_callback:id() | undefined, egraph_k(), state()) ->
        {false | true | {true, egraph_callback:id()}, state()}.
create(undefined, V, State) ->
    create_or_update_info(V, State);
create(Key, V, State) ->
    Info2 = V#{<<"source">> => Key},
    create_or_update_info(Info2, State).

%% @doc Create a new entry along with an expiry of some seconds.
-spec create(egraph_callback:id() | undefined, egraph_k(),
             [{binary(), binary()}], state()) ->
    {false | true | {true, egraph_callback:id()}, state()}.
create(Key, V, _QsProplist, State) ->
    create(Key, V, State).

%% @doc Read a given entry from the store based on its Key.
-spec read(egraph_callback:id(), state()) ->
        { {ok, egraph_k()} |
          {function, Fun :: function()},
          {error, not_found}, state()}.
read(undefined, State) ->
    %% return everthing you have
    {{function, fun read_all_resource/3}, State};
read(Key, State) ->
    QsProplists = proplists:get_value(proplist, State, []),
    KeyType = proplists:get_value(<<"keytype">>, QsProplists, undefined),
    ReceivedDestination = proplists:get_value(<<"destination">>, QsProplists, undefined),
    {RawKey, DestinationRawKey} = process_input_args(Key, KeyType, ReceivedDestination),
    case DestinationRawKey of
        undefined ->
            case read_resource(RawKey) of
                {ok, Vals} ->
                    {{ok, Vals}, State};
                R ->
                    {R, State}
            end;
        _ ->
            case read_resource(RawKey, DestinationRawKey) of
                {ok, Vals} ->
                    {{ok, Vals}, State};
                R ->
                    {R, State}
            end
    end.

%% @doc Update an existing resource.
%%
%% The modified resource is validated before this function is called.
-spec update(egraph_callback:id(), egraph_k(), state()) -> {boolean(), state()}.
update(Key, V, State) ->
    Info2 = V#{<<"source">> => Key},
    create_or_update_info(Info2, State).

%% @doc Update an existing resource with some expiry seconds.
-spec update(egraph_callback:id(), egraph_k(), integer(), state()) ->
    {boolean(), state()}.
update(Key, V, _QsProplist, State) ->
    update(Key, V, State).

%% @doc Delete an existing resource.
-spec delete(egraph_callback:id(), state()) -> {boolean(), state()}.
delete(Key, State) ->
    QsProplists = proplists:get_value(proplist, State, []),
    KeyType = proplists:get_value(<<"keytype">>, QsProplists, undefined),
    ReceivedDestination = proplists:get_value(<<"destination">>, QsProplists, undefined),
    {RawKey, DestinationRawKey} = process_input_args(Key, KeyType, ReceivedDestination),
    case DestinationRawKey of
        undefined ->
            {delete_resource(RawKey), State};
        _ ->
            {delete_resource(RawKey, DestinationRawKey), State}
    end.

%%%===================================================================
%%% Internal
%%%===================================================================

create_or_update_info(Info, State) ->
    #{ <<"source">> := Key,
       <<"destination">> := Destination,
       <<"details">> := Details
     } = Info,
    true = is_map(Details),
    PreferredCompressionId = maps:get(<<"compression_id">>, Info, undefined),
    RawKey = egraph_util:generate_xxhash_binary(
               egraph_util:convert_to_binary(Key)),
    DestinationRawKey = egraph_util:generate_xxhash_binary(
                          egraph_util:convert_to_binary(Destination)),
    TimeoutMsec = egraph_config_util:mysql_rw_timeout_msec(link),
    BaseTableName = ?EGRAPH_TABLE_LINK_BASE,
    TableName = egraph_shard_util:sharded_tablename(key, RawKey, BaseTableName),
    UpdatedDetails = Details#{
                       ?EGRAPH_DETAILS_SPECIAL_SOURCE => egraph_util:convert_to_binary(Key),
                       ?EGRAPH_DETAILS_SPECIAL_DESTINATION => egraph_util:convert_to_binary(Destination)
                      },
    SerializedDetails = egraph_compression_util:serialize_data(
                          UpdatedDetails, PreferredCompressionId),

    HexKey = egraph_util:bin_to_hex_binary(RawKey),
    HexDestination = egraph_util:bin_to_hex_binary(DestinationRawKey),
    ReturnLoc = iolist_to_binary(
                  [HexKey,
                   <<"?destination=">>,
                   HexDestination,
                   <<"&keytype=rawhex">>]),
    case read_resource(RawKey, DestinationRawKey, create) of
        {error, not_found} ->
            case sql_insert_record(TableName, RawKey,
                                   SerializedDetails,
                                   DestinationRawKey,
                                   TimeoutMsec) of
                true ->
                    {{true, ReturnLoc}, State};
                false ->
                    {false, State}
            end;
        {ok, [DbInfo]} ->
            DbStoredDetailsInfo = maps:get(<<"details">>, DbInfo),
            lager:debug("DbStoredDetailsInfo = ~p", [DbStoredDetailsInfo]),
            DbStoredKey = maps:get(?EGRAPH_DETAILS_SPECIAL_SOURCE,
                                   DbStoredDetailsInfo),
            DbStoredDestination = maps:get(?EGRAPH_DETAILS_SPECIAL_DESTINATION,
                                           DbStoredDetailsInfo),
            lager:debug("[compare] ~p == ~p", [DbStoredKey, egraph_util:convert_to_binary(Key)]),
            lager:debug("[compare] ~p == ~p", [DbStoredDestination, egraph_util:convert_to_binary(Destination)]),
            %% TODO read details and check for collision
            case {DbStoredKey == egraph_util:convert_to_binary(Key),
                  DbStoredDestination == egraph_util:convert_to_binary(Destination)} of
                {true, true} ->
                    %% the index already exists
                    OldVersion = maps:get(<<"version">>, DbInfo),
                    %% TODO: Check for failures while updating info
                    sql_update_record(TableName,
                                      OldVersion,
                                      RawKey,
                                      DestinationRawKey,
                                      SerializedDetails,
                                      TimeoutMsec),
                    {{true, ReturnLoc}, State};
                _ ->
                    %% TODO: How did this happen?
                    lager:error("[link] Collission in hash detected between DbStoredKey = ~p and Key = ~p or DbStoredDestination = ~p and Destination = ~p",
                                [DbStoredKey, egraph_util:convert_to_binary(Key),
                                 DbStoredDestination, egraph_util:convert_to_binary(Destination)]),
                    {false, State}
            end
    end.

%% TODO: Find the cluster nodes which must have this data and delete from there.
delete_resource(RawKey) ->
    BaseTableName = ?EGRAPH_TABLE_LINK_BASE,
    TableName = egraph_shard_util:sharded_tablename(key, RawKey, BaseTableName),
    Q = iolist_to_binary([<<"DELETE FROM ">>,
                          TableName,
                          <<" WHERE source=?">>]),
    %% TODO: should we check for collisions?
    Params = [RawKey],
    TimeoutMsec = egraph_config_util:mysql_rw_timeout_msec(link),
    PoolName = egraph_config_util:mysql_rw_pool(link),
    case egraph_sql_util:mysql_write_query(
           PoolName, Q, Params, TimeoutMsec) of
        ok ->
            true;
        _ ->
            false
    end.

delete_resource(RawKey, DestinationRawKey) ->
    BaseTableName = ?EGRAPH_TABLE_LINK_BASE,
    TableName = egraph_shard_util:sharded_tablename(
                 key, RawKey, BaseTableName),
    Q = iolist_to_binary([<<"DELETE FROM ">>,
                          TableName,
                          <<" WHERE source=? and destination=?">>]),
    %% TODO: should we check for collisions?
    Params = [RawKey, DestinationRawKey],
    TimeoutMsec = egraph_config_util:mysql_rw_timeout_msec(link),
    PoolName = egraph_config_util:mysql_rw_pool(link),
    case egraph_sql_util:mysql_write_query(
           PoolName, Q, Params, TimeoutMsec) of
        ok ->
            true;
        _ ->
            false
    end.

%% TODO: Find the cluster nodes which must have this data and pull from there.
-spec read_resource(binary()) -> {ok, [map()]} | {error, term()}.
read_resource(RawKey) ->
    BaseTableName = ?EGRAPH_TABLE_LINK_BASE,
    TableName = egraph_shard_util:sharded_tablename(
                 key, RawKey, BaseTableName),
    Q = iolist_to_binary([<<"SELECT * FROM ">>,
                          TableName,
                          <<" WHERE source=?">>]),
    Params = [RawKey],
    read_generic_resource(Q, Params).

%% TODO: Find the cluster nodes which must have this data and pull from there.
-spec read_resource(binary(), binary() | create) -> {ok, [map()]} | {error, term()}.
read_resource(RawKey, create) ->
    BaseTableName = ?EGRAPH_TABLE_LINK_BASE,
    TableName = egraph_shard_util:sharded_tablename(
                 key, RawKey, BaseTableName),
    Q = iolist_to_binary([<<"SELECT * FROM ">>,
                          TableName,
                          <<" WHERE source=?">>]),
    Params = [RawKey],
    read_generic_resource(Q, Params, create, BaseTableName, TableName);
read_resource(RawKey, DestinationRawKey) ->
    BaseTableName = ?EGRAPH_TABLE_LINK_BASE,
    TableName = egraph_shard_util:sharded_tablename(
                 key, RawKey, BaseTableName),
    Q = iolist_to_binary([<<"SELECT * FROM ">>,
                          TableName,
                          <<" WHERE source=? and destination=?">>]),
    Params = [RawKey, DestinationRawKey],
    read_generic_resource(Q, Params).

read_resource(RawKey, DestinationRawKey, create) ->
    BaseTableName = ?EGRAPH_TABLE_LINK_BASE,
    TableName = egraph_shard_util:sharded_tablename(
                 key, RawKey, BaseTableName),
    Q = iolist_to_binary([<<"SELECT * FROM ">>,
                          TableName,
                          <<" WHERE source=? and destination=?">>]),
    Params = [RawKey, DestinationRawKey],
    read_generic_resource(Q, Params, create, BaseTableName, TableName).

-spec read_all_resource(ShardKey :: integer(),
                        Limit :: integer(),
                        Offset :: integer()) ->
    {ok, [map()], NewOffset :: integer()} | {error, term()}.
read_all_resource(ShardKey, Limit, Offset) ->
    BaseTableName = ?EGRAPH_TABLE_LINK_BASE,
    TableName = egraph_shard_util:sharded_tablename(
                  shard_id, ShardKey, BaseTableName),
    Q = iolist_to_binary([<<"SELECT * FROM ">>,
                          TableName,
                          <<" LIMIT ? OFFSET ?">>]),
    Params = [Limit, Offset],
    case read_generic_resource(Q, Params) of
        {ok, R} ->
            {ok, R, Offset + length(R)};
        E ->
            E
    end.

read_generic_resource(Query, Params) ->
    ConvertToMap = true,
    TimeoutMsec = egraph_config_util:mysql_ro_timeout_msec(link),
    ReadPools = egraph_config_util:mysql_ro_pools(link),
    case egraph_sql_util:mysql_query(
           ReadPools, Query, Params, TimeoutMsec, ConvertToMap) of
        {ok, Maps} ->
            Maps2 = lists:foldl(fun transform_result/2, [], Maps),
            {ok, Maps2};
        Error ->
            Error
    end.

read_generic_resource(Query, Params, create, BaseTableName, TableName) ->
    ConvertToMap = true,
    TimeoutMsec = egraph_config_util:mysql_rw_timeout_msec(link),
    IsRetry = false,
    IsReadOnly = false,
    PoolName = egraph_config_util:mysql_rw_pool(link),
    case egraph_sql_util:run_sql_read_query_for_shard(
           PoolName,
           BaseTableName,
           [PoolName],
           TableName,
           Query, Params, TimeoutMsec, IsRetry, IsReadOnly,
           ConvertToMap) of
        {ok, Maps} ->
            Maps2 = lists:foldl(fun transform_result/2, [], Maps),
            {ok, Maps2};
        Error ->
            Error
    end.

transform_result(E, AccIn) ->
    E2 = case maps:get(<<"source">>, E, undefined) of
             undefined ->
                 E;
             Source ->
                 %% egraph_shard_util:convert_xxhash_bin_to_integer(Source)
                 E#{<<"source">> =>
                    egraph_util:bin_to_hex_binary(Source)}
         end,
    E3 = case maps:get(<<"destination">>, E2, undefined) of
             undefined ->
                 E2;
             Destination ->
                 E2#{<<"destination">> =>
                     egraph_util:bin_to_hex_binary(Destination)}
         end,
    E4 = case maps:get(<<"details">>, E3, undefined) of
             undefined ->
                 E3;
             Details ->
                 E3#{<<"details">> =>
                     egraph_compression_util:deserialize_data(Details)}
         end,
    E5 = case maps:get(<<"details_hash">>, E4, undefined) of
             undefined ->
                 E4;
             DetailsHash ->
                 E4#{<<"details_hash">> =>
                     egraph_util:bin_to_hex_binary(DetailsHash)}
         end,
    [E5 | AccIn].

sql_insert_record(TableName, RawKey, SerializedDetails, DestinationRawKey, TimeoutMsec) ->
    DefaultVersion = 0,
    DetailsHash = egraph_util:generate_xxhash_binary(
                    egraph_util:convert_to_binary(SerializedDetails)),
    Q = iolist_to_binary([<<"INSERT INTO ">>,
                          TableName,
                          <<" VALUES(?, ?, ?, ?, ?)">>]),
    Params = [RawKey, DestinationRawKey, DefaultVersion, DetailsHash, SerializedDetails],
    %% TODO: find out the cluster nodes which must persist this data
    %%       and save it there.
    PoolName = egraph_config_util:mysql_rw_pool(link),
    case egraph_sql_util:mysql_write_query(
           PoolName, Q, Params, TimeoutMsec) of
        ok ->
            true;
        _ ->
            false
    end.

sql_update_record(TableName, OldVersion, RawKey, DestinationRawKey,
                  SerializedDetails, TimeoutMsec) ->
    Version = OldVersion + 1,
    DetailsHash = egraph_util:generate_xxhash_binary(
                    egraph_util:convert_to_binary(SerializedDetails)),
    Q = iolist_to_binary([<<"UPDATE ">>,
                          TableName,
                          <<" SET version=?, details_hash=?, details=? WHERE source=? and destination=? and version=?">>]),
    Params = [Version, DetailsHash, SerializedDetails,
              RawKey, DestinationRawKey, OldVersion],
    %% TODO: need to check whether update indeed happened or not because
    %% the where clause may not match.
    PoolName = egraph_config_util:mysql_rw_pool(link),
    case egraph_sql_util:mysql_write_query(
           PoolName, Q, Params, TimeoutMsec) of
        ok -> true;
        _ -> false
    end.

process_input_args(Key, KeyType, ReceivedDestination) ->
    case {KeyType, ReceivedDestination} of
        {<<"rawhex">>, undefined} ->
            {egraph_util:hex_binary_to_bin(Key), undefined};
        {<<"rawhex">>, _} ->
            {egraph_util:hex_binary_to_bin(Key),
             egraph_util:hex_binary_to_bin(ReceivedDestination)};
        {<<"rawint">>, undefined} ->
            {egraph_shard_util:convert_integer_to_xxhash_bin(
               egraph_util:convert_to_integer(Key)),
             egraph_shard_util:convert_integer_to_xxhash_bin(
               egraph_util:convert_to_integer(ReceivedDestination))};
        {_, undefined} ->
            {egraph_util:generate_xxhash_binary(
               egraph_util:convert_to_binary(Key)),
              undefined};
        {_, _} ->
            {egraph_util:generate_xxhash_binary(
               egraph_util:convert_to_binary(Key)),
             egraph_util:generate_xxhash_binary(
               egraph_util:convert_to_binary(ReceivedDestination))}
    end.

-spec search(binary(), destination | destination_info) -> {ok, [binary()]} | {error, term()}.
search(RawKey, destination) ->
    BaseTableName = ?EGRAPH_TABLE_LINK_BASE,
    TableName = egraph_shard_util:sharded_tablename(
                 key, RawKey, BaseTableName),
    Query = iolist_to_binary([<<"SELECT destination FROM ">>,
                              TableName,
                              <<" WHERE source=?">>]),
    Params = [RawKey],
    ConvertToMap = false,
    TimeoutMsec = egraph_config_util:mysql_ro_timeout_msec(link),
    ReadPools = egraph_config_util:mysql_ro_pools(link),
    case egraph_sql_util:mysql_query(
           ReadPools, Query, Params, TimeoutMsec, ConvertToMap) of
        {ok, {_ColumnNames, MultipleRowValues}} ->
            {ok, lists:flatten(MultipleRowValues)};
        Error ->
            Error
    end;
search(RawKey, destination_info) ->
    BaseTableName = ?EGRAPH_TABLE_LINK_BASE,
    TableName = egraph_shard_util:sharded_tablename(
                 key, RawKey, BaseTableName),
    Query = iolist_to_binary([<<"SELECT * FROM ">>,
                              TableName,
                              <<" WHERE source=?">>]),
    Params = [RawKey],
    ConvertToMap = true,
    TimeoutMsec = egraph_config_util:mysql_ro_timeout_msec(link),
    ReadPools = egraph_config_util:mysql_ro_pools(link),
    case egraph_sql_util:mysql_query(
           ReadPools, Query, Params, TimeoutMsec, ConvertToMap) of
        {ok, Maps} ->
            Maps2 = lists:foldl(fun transform_result/2, [], Maps),
            {ok, Maps2};
            %%
            %% Send raw information
            %% {ok, Maps};
        Error ->
            Error
    end.

