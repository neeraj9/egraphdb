%%%-------------------------------------------------------------------
%%% @author neerajsharma
%%% @copyright (C) 2018, Neeraj Sharma
%%% @doc
%%%
%%% @end
%%% %CopyrightBegin%
%%%
%%% Copyright Neeraj Sharma <neeraj.sharma@alumni.iitg.ernet.in> 2017.
%%% All Rights Reserved.
%%%
%%% Licensed under the Apache License, Version 2.0 (the "License");
%%% you may not use this file except in compliance with the License.
%%% You may obtain a copy of the License at
%%%
%%%     http://www.apache.org/licenses/LICENSE-2.0
%%%
%%% Unless required by applicable law or agreed to in writing, software
%%% distributed under the License is distributed on an "AS IS" BASIS,
%%% WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
%%% See the License for the specific language governing permissions and
%%% limitations under the License.
%%%
%%% %CopyrightEnd%
%%%-------------------------------------------------------------------
-module(egraph_v1_search_model).
%% -behaviour(egraph_callback).
-export([init/0, init/2, terminate/1, % CRUD
         validate/2, create/3, read/2, update/3, delete/2]).
-export([create/4, update/4]).
-export_type([egraph_k/0]).

-include("egraph_constants.hrl").

-type egraph_k() :: binary().
-type state() :: term().

-define(LAGER_ATTRS, [{type, model}]).

%%%===================================================================
%%% API
%%%===================================================================

%%%===================================================================
%%% Callbacks
%%%===================================================================

%% @doc Initialize the state that the handler will carry for
%% a specific request throughout its progression. The state
%% is then passed on to each subsequent call to this model.
-spec init() -> state().
init() ->
    nostate.

init(_, QsProplist) ->
    [{proplist, QsProplist}].

%% @doc At the end of a request, the state is passed back in
%% to allow for clean up.
-spec terminate(state()) -> term().
terminate(_State) ->
    ok.

%% @doc Return, via a boolean value, whether the user-submitted
%% data structure is considered to be valid by this model's standard.
-spec validate(egraph_k() | term(), state()) -> {boolean(), state()}.
validate(V, State) ->
    {is_map(V) orelse is_list(V) orelse is_boolean(V), State}.

%% @doc Create a new entry. If the id is `undefined', the user
%% has not submitted an id under which to store the resource:
%% the id needs to be generated by the model, and (if successful),
%% returned via `{true, GeneratedId}'.
%% Otherwise, a given id will be passed, and a simple `true' or
%% `false' value may be returned to confirm the results.
%%
%% The created resource is validated before this function is called.
-spec create(egraph_callback:id() | undefined, egraph_k(), state()) ->
        {false | true | {true, egraph_callback:id()}, state()}.
create(undefined, V, State) ->
    %% {false, State}.
    process_generic_search(V, State).

%% @doc Create a new entry along with an expiry of some seconds.
-spec create(egraph_callback:id() | undefined, egraph_k(),
             [{binary(), binary()}], state()) ->
    {false | true | {true, egraph_callback:id()}, state()}.
create(Key, V, _QsProplist, State) ->
    create(Key, V, State).

%% @doc Read a given entry from the store based on its Key.
-spec read(egraph_callback:id(), state()) ->
        { {ok, egraph_k()} |
          {error, not_found}, state()}.
read(undefined, State) ->
    %% TODO return everthing you have
    {{error, not_found}, State};
read(Key, State) ->
    QsProplists = proplists:get_value(proplist, State),
    RawKey = egraph_util:generate_xxhash_binary(
               egraph_util:convert_to_binary(Key)),

    case proplists:get_value(<<"traverse">>, QsProplists, undefined) of
        undefined ->
            MaxDepth = egraph_util:convert_to_integer(
                         proplists:get_value(<<"maxdepth">>, QsProplists, 0)),
            Vals = egraph_api:recursive_get_destination(RawKey, 0, MaxDepth),
            {{ok, Vals}, State};
        <<"dfs">> ->
            DestinationKey = proplists:get_value(<<"destination">>, QsProplists, undefined),
            %% assert that destination key exists
            true = (undefined =/= DestinationKey),
            DestinationRawKey = egraph_util:generate_xxhash_binary(
                                  egraph_util:convert_to_binary(DestinationKey)),
            TraverseFun = fun(SourceId) ->
                                  case egraph_link_model:search(SourceId, destination) of
                                      {ok, DestinationIds} ->
                                          DestinationIds;
                                      _ ->
                                          []
                                  end
                          end,
            Ids = egraph_dfs_algo:dfs(TraverseFun, RawKey, DestinationRawKey),
            GetDetailsFun = fun(DestinationInfo, AccIn) ->
                                    [DestinationInfo | AccIn]
                            end,
            %% Note that details may not be in correct order of path traversal
            Details = egraph_api:get_detail_fold(GetDetailsFun, [], Ids),
            Vals = #{
              <<"path">> => [egraph_util:bin_to_hex_binary(X) || X <- Ids],
              <<"details">> => Details},
            {{ok, Vals}, State}
    end.


%% @doc Update an existing resource.
%%
%% The modified resource is validated before this function is called.
-spec update(egraph_callback:id(), egraph_k(), state()) -> {boolean(), state()}.
update(_Key, _V, State) ->
    {false, State}.

%% @doc Update an existing resource with some expiry seconds.
-spec update(egraph_callback:id(), egraph_k(), integer(), state()) ->
    {boolean(), state()}.
update(Key, V, _QsProplist, State) ->
    update(Key, V, State).

%% @doc Delete an existing resource.
-spec delete(egraph_callback:id(), state()) -> {boolean(), state()}.
delete(_Key, State) ->
    {false, State}.

%%%===================================================================
%%% Internal
%%%===================================================================

-spec process_generic_search(Info :: map(), State :: state()) ->
    {stop, state()}.
process_generic_search(#{<<"query">> := Query} = _Info, State) ->
    A = http_client_accept_content_type(<<"*/*">>),
    lager:debug("A = ~p", [A]),
    B = http_client_accept_content_type(<<"application/json">>),
    lager:debug("B = ~p", [B]),
    C = http_client_accept_content_type(<<"application/x-erlang-binary">>),
    D = http_client_accept_content_type(<<"application/x-erlang-stream-binary">>),
    case {A orelse B, C, D} of
        {false, _, true} ->
            process_query(erlang_stream_binary, Query, State);
        %% TODO: support erlang_binary
        %%{false, true, false} ->
        %%    process_query(erlang_binary, Query, State);
        {true, _, _} ->
            process_query(json, Query, State)
    end.

process_query(json,
              #{<<"type">> := <<"index">>,
                <<"conditions">> := #{
                    <<"any">> := AnyConditions,
                    <<"filters">> := Filters
                   },
                <<"selected_paths">> := SelectedPaths} = _Query, State) ->
    Ids = egraph_api:search_id(AnyConditions),
    MaxDepth = -1,  %% do not traverse links
    IsConcurrent = true,
    egraph_api:stream_selected_node_json(
      Ids, Filters, SelectedPaths, IsConcurrent, MaxDepth),
    {stop, State};
process_query(erlang_stream_binary,
              #{<<"type">> := <<"index">>,
                <<"conditions">> := #{
                    <<"any">> := AnyConditions,
                    <<"filters">> := Filters
                   },
                <<"selected_paths">> := SelectedPaths} = _Query, State) ->
    IsConcurrent = true,
    Ids = egraph_api:search_id(AnyConditions),
    egraph_api:stream_selected_node_x_erlang_stream_binary(
      Ids, Filters, SelectedPaths, IsConcurrent),
    {stop, State}.

http_client_accept_content_type(ContentType) ->
    egraph_api:http_client_accept_content_type(ContentType).

